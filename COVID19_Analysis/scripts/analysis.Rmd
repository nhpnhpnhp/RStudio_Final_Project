---
title: "Phân tích Dữ liệu COVID_19 - Machine learning"
author: "Lưu Trần Kim Phú - 23133055"
date: "2025-05-13"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
  pdf_document: default
---   

## 1. CHUẨN BỊ DỮ LIỆU
```{r}
# =====================================================
# 1.1: Cài đặt và nạp các gói cần thiết
# =====================================================
install.packages("tidyverse")
install.packages("caret")
install.packages("ggplot2")
install.packages("data.table")
install.packages("corrplot")
install.packages("lubridate")
install.packages("cluster")
install.packages("e1071")
install.packages("randomForest")
install.packages("readr")
install.packages("knitr")
install.packages("factoextra")
install.packages("forecast")
install.packages("pROC")

library(tidyverse)    # Xử lý và trực quan hóa dữ liệu
library(caret)        # Học máy
library(ggplot2)      # Vẽ biểu đồ
library(data.table)   # Xử lý dữ liệu nhanh
library(corrplot)     # Ma trận tương quan
library(lubridate)    # Xử lý ngày tháng
library(cluster)      # Phân cụm
library(e1071)        # SVM
library(randomForest) # Random Forest
library(readr)
library(knitr)
library(factoextra)
library(forecast)
library(pROC)
```
**Phân tích**:
- **Chức năng**:
  - **Cài đặt gói** (`install.packages`): Cài các gói cần thiết nếu chưa có trên máy.
    - `tidyverse`: Bộ công cụ xử lý dữ liệu (dplyr, tidyr) và trực quan hóa (ggplot2).
    - `caret`: Hỗ trợ học máy (mô hình, đánh giá).
    - `ggplot2`: Vẽ biểu đồ (histogram, đường cong).
    - `data.table`: Xử lý dữ liệu lớn nhanh chóng.
    - `corrplot`: Vẽ ma trận tương quan.
    - `lubridate`: Xử lý ngày tháng.
    - `cluster`: Phân cụm (K-Means, Hierarchical).
    - `e1071`: Hỗ trợ SVM và các hàm thống kê.
    - `randomForest`: Triển khai Random Forest.
    - `readr`: Đọc tệp CSV nhanh (thuộc tidyverse).
    - `knitr`: Tạo bảng đẹp với `kable()`.
  - **Tải gói** (`library`): Kích hoạt các gói để sử dụng trong mã.
- **Lý thuyết học máy**: Việc tải thư viện là bước chuẩn bị để triển khai các thuật toán học máy (hồi quy, phân loại, phân cụm) và xử lý dữ liệu.
- **Ý nghĩa trong COVID-19**: Các thư viện như `tidyverse` giúp làm sạch dữ liệu dịch bệnh (thường thiếu hoặc không đồng nhất), `caret` và `randomForest` hỗ trợ dự đoán số ca tử vong, và `ggplot2` trực quan hóa xu hướng lây lan.
- **Kết quả**:
  - Tất cả gói được cài đặt và tải mà không báo lỗi.
  - Nếu gói đã cài, `install.packages` sẽ bỏ qua; `library` kích hoạt gói để sử dụng.

```{r}
# =====================================================
# 1.2: Tải và đọc dữ liệu đầu vào
# =====================================================
worldometer <- read_csv("../data/worldometer_data.csv")
covid_clean <- read_csv("../data/covid_19_clean_complete.csv")

# Xem cấu trúc dữ liệu
str(worldometer)
str(covid_clean)
```

**Phân tích**:
- **Chức năng**:
  - **`read_csv("../data/worldometer_data.csv")`**: Đọc tệp CSV từ thư mục `data/` (nằm ngoài thư mục `scripts/`).
    - `worldometer`: Lưu dữ liệu vào biến dạng tibble (data frame).
  - **Tương tự cho `covid_clean`**: Đọc `covid_19_clean_complete.csv`.
  - **`str(worldometer)` và `str(covid_clean)`**: Hiển thị cấu trúc dữ liệu (tên cột, kiểu dữ liệu, vài giá trị đầu).
- **Lý thuyết học máy**: Tải dữ liệu là bước đầu tiên trong quy trình học máy, cung cấp nguyên liệu cho phân tích. Kiểm tra cấu trúc giúp xác định các đặc trưng (features) và kiểu dữ liệu để xử lý tiếp.
- **Ý nghĩa trong COVID-19**:
  - `worldometer_data.csv`: Chứa số liệu tổng hợp theo quốc gia (như `TotalCases`, `TotalDeaths`, `Population`), giúp phân tích tình hình dịch bệnh toàn cầu.
  - `covid_19_clean_complete.csv`: Chứa dữ liệu thời gian (như `Date`, `Confirmed`), phù hợp để phân tích xu hướng lây lan.
  - Kiểm tra cấu trúc giúp phát hiện vấn đề sớm (như cột `Date` không đúng định dạng).
- **Kết quả**:
  - `worldometer`: Có các cột như `Country/Region`, `TotalCases` (numeric), `TotalDeaths` (numeric), `Population` (numeric), `TotalTests` (numeric), `Continent` (character).
  - `covid_clean`: Có các cột như `Province/State`, `Country/Region`, `Date` (character hoặc Date), `Confirmed` (numeric), `Deaths` (numeric), `Recovered` (numeric).

================================================================================

## 2. PHÂN TÍCH KHÁM PHÁ (EDA)
```{r}
# =====================================================
# -> Kiểm tra giá trị thiếu
# =====================================================
missing_worldometer <- colSums(is.na(worldometer))
missing_covid_clean <- colSums(is.na(covid_clean))

# Hiển thị dưới dạng bảng
kable(missing_worldometer, caption = "Giá trị thiếu trong worldometer_data")
kable(missing_covid_clean, caption = "Giá trị thiếu trong covid_19_clean_complete")
```
  
  
```{r}
# =====================================================
# -> Chuẩn hóa định dạng ngày tháng trong covid_clean
# =====================================================
covid_clean <- covid_clean %>%
  mutate(Date = as_date(Date, format = "%Y-%m-%d"))

# Đảm bảo cột số trong worldometer
worldometer <- worldometer %>%
  mutate(across(c(TotalCases, TotalDeaths, Population, TotalTests), as.numeric))

# Kiểm tra lại
summary(covid_clean$Date)
summary(worldometer %>% select(TotalCases, TotalDeaths, Population, TotalTests))
```

<!-- ===================================================== -->
<!-- Phân phối Số ca Nhiễm/Tử vong -->
<!-- ===================================================== -->

```{r}
# =====================================================
# 2.1. Histogram số ca nhiễm
# =====================================================
p1 <- ggplot(worldometer, aes(x = TotalCases)) +
  geom_histogram(binwidth = 10000, fill = "#1E90FF", color = "white", alpha = 0.9) + # Xanh dương, viền trắng
  labs(title = "Phân phối Số ca Nhiễm COVID-19 Theo Quốc Gia",
       subtitle = "Dữ liệu tổng hợp từ Worldometer",
       x = "Tổng Số ca Nhiễm", y = "Số Quốc Gia") +
  theme_minimal(base_family = "Arial") +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    panel.grid.major = element_line(color = "grey80", size = 0.3),
    panel.grid.minor = element_line(color = "grey90", size = 0.1),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  ) +
  scale_x_continuous(labels = scales::comma) + # Định dạng số lớn (thêm dấu phẩy)
  scale_y_continuous(expand = c(0, 0)) # Bắt đầu từ 0

ggsave("../outputs/plots/histogram_cases.png", p1, width = 8, height = 5, dpi = 300, bg = "white")
```


```{r}
# =====================================================
# 2.2. Ma trận tương quan
# -> Phân tích mối quan hệ giữa các biến số trong worldometer.
# =====================================================
# Chọn cột số
numeric_cols <- worldometer %>% select_if(is.numeric)

# Tính ma trận tương quan
cor_matrix <- cor(numeric_cols, use = "complete.obs")

# Vẽ ma trận tương quan
corrplot(cor_matrix, method = "color", type = "upper", tl.cex = 0.8)
png("../outputs/plots/correlation_matrix.png")
corrplot(cor_matrix, method = "color", type = "upper", tl.cex = 0.8)
dev.off()
```


```{r}
# =====================================================
# 2.3. Xu hướng thời gian
# -> Phân tích xu hướng số ca nhiễm toàn cầu theo thời gian trong covid_clean
# =====================================================
# Tổng hợp số ca nhiễm theo ngày
global_trend <- covid_clean %>%
  group_by(Date) %>%
  summarise(TotalConfirmed = sum(Confirmed, na.rm = TRUE))

# Vẽ biểu đồ xu hướng với các tùy chỉnh
ggplot(global_trend, aes(x = Date, y = TotalConfirmed)) +
  geom_line(color = "steelblue", size = 1) +  # Đường kẻ màu xanh đậm, dày hơn
  geom_point(color = "steelblue", size = 1.5, alpha = 0.6) +  # Thêm điểm dữ liệu
  labs(title = "Xu hướng ca nhiễm COVID-19 toàn cầu",
       x = "Ngày", 
       y = "Tổng số ca nhiễm") +
  theme_minimal(base_size = 12) +  # Cỡ chữ cơ bản
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),  # Canh giữa tiêu đề
    axis.title = element_text(face = "bold"),  # Nhãn trục in đậm
    panel.grid.minor = element_blank(),  # Bỏ đường lưới phụ
    panel.background = element_rect(fill = "white"),  # Nền trắng
    plot.background = element_rect(fill = "white")  # Nền trắng cho toàn bộ biểu đồ
  ) +
  scale_y_continuous(labels = scales::comma)  # Định dạng số trên trục y

# Lưu biểu đồ với chất lượng cao
ggsave("../outputs/plots/time_series.png", 
       width = 10, 
       height = 6, 
       dpi = 300, 
       bg = "white")
```

================================================================================

## 3. TIỀN XỬ LÝ
```{r}
# =====================================================
# 3.1. Xử lý giá trị thiếu
# -> Điền giá trị thiếu bằng cách Điền giá trị thiếu trong worldometer bằng trung bình
# =====================================================
worldometer <- worldometer %>%
  mutate(across(where(is.numeric), ~ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>%
  mutate(Continent = ifelse(is.na(Continent), "Unknown", Continent))

# Kiểm tra lại
kable(colSums(is.na(worldometer)), caption = "Giá trị thiếu sau xử lý")
```


```{r}
# =====================================================
# 3.2 Chuẩn hóa (Scaling)
# -> Chuẩn hóa các cột số trong worldometer về trung bình 0 và độ lệch chuẩn 1.
# =====================================================
preprocess_params <- preProcess(worldometer %>% select_if(is.numeric),
                               method = c("center", "scale"))
worldometer_scaled <- predict(preprocess_params, worldometer)
summary(worldometer_scaled %>% select(TotalCases, TotalDeaths, Population, TotalTests))
```


```{r}
# =====================================================
# 3.3 Mã hóa Biến Hạng mục
# -> Mã hóa cột Continent trong worldometer (nếu có) thành số.
# =====================================================
worldometer_scaled <- worldometer_scaled %>%
  mutate(Continent = as.factor(Continent)) %>%
  mutate(Continent = as.numeric(Continent))
summary(worldometer_scaled$Continent)
```


```{r}
# =====================================================
# 3.4 Chọn Đặc trưng
# -> Chọn các đặc trưng quan trọng cho mô hình học máy.
# =====================================================
worldometer_model <- worldometer_scaled %>%
  select(TotalCases, TotalDeaths, Population, TotalTests, Continent)
str(worldometer_model)
```

================================================================================

## 4. MÔ HÌNH HỌC MÁY (MACHINE LEARNING).
```{r}
# =====================================================
# 4.1 Hồi quy (Dự đoán Số ca Tử vong)
# - Dự đoán số ca tử vong giúp các quốc gia chuẩn bị giường bệnh, máy thở, và nguồn lực y tế.
# =====================================================

# Kiểm tra NA
print("Giá trị thiếu trong worldometer_model:")
kable(colSums(is.na(worldometer_model)), caption = "Giá trị thiếu trước mô hình")

# Điền NA (nếu còn)
worldometer_model <- worldometer_model %>%
  mutate(across(where(is.numeric), ~ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>%
  mutate(Continent = ifelse(is.na(Continent), 
                            names(sort(table(Continent), decreasing = TRUE))[1], 
                            Continent))

# Kiểm tra lại
if (any(is.na(worldometer_model))) {
  stop("Dữ liệu vẫn chứa NA. Vui lòng kiểm tra lại.")
}

# Chia dữ liệu train/test
set.seed(123)
trainIndex <- createDataPartition(worldometer_model$TotalDeaths, p = 0.8, list = FALSE)
train_data <- worldometer_model[trainIndex, ]
test_data <- worldometer_model[-trainIndex, ]

# Xây dựng mô hình hồi quy tuyến tính
model_lm <- train(TotalDeaths ~ TotalCases + Population + TotalTests + Continent,
                  data = train_data,
                  method = "lm")

# Dự đoán và đánh giá
predictions <- predict(model_lm, test_data)
results <- postResample(predictions, test_data$TotalDeaths)

# Hiển thị kết quả
print("Kết quả mô hình:")
print(results)

# Lưu biểu đồ với nền trắng
png("../outputs/plots/model_performance.png", bg = "white")
plot(test_data$TotalDeaths, predictions, 
     main = "Thực tế vs Dự đoán",
     xlab = "Tổng số ca tử vong thực tế", 
     ylab = "Tổng số ca tử vong dự đoán",
     col = "black",  # Màu điểm
     pch = 19,       # Hình dạng điểm
     col.main = "black",  # Màu tiêu đề
     col.lab = "black",   # Màu nhãn trục
     col.axis = "black")  # Màu trục
abline(0, 1, col = "red")
dev.off()
```


```{r}
# =====================================================
# 4.2 Phân loại (Phân loại Mức độ Nghiêm trọng)
# - Phân loại mức độ nghiêm trọng giúp xác định các quốc gia cần hỗ trợ y tế khẩn cấp.
# =====================================================
# Tạo biến mục tiêu
worldometer_model <- worldometer_model %>%
  mutate(Severity = as.factor(ifelse(TotalDeaths > median(TotalDeaths, na.rm = TRUE), "High", "Low")))

# Kiểm tra phân phối lớp
print("Phân phối lớp Severity:")
table(worldometer_model$Severity)

# Biến đổi đặc trưng (giảm tách biệt)
worldometer_model <- worldometer_model %>%
  mutate(LogTotalCases = log1p(TotalCases))

# Chia dữ liệu train/test
set.seed(123)
trainIndex <- createDataPartition(worldometer_model$Severity, p = 0.8, list = FALSE)
train_data <- worldometer_model[trainIndex, ]
test_data <- worldometer_model[-trainIndex, ]

# Mô hình glmnet (có điều chuẩn)
model_glm <- train(Severity ~ LogTotalCases + Population + TotalTests + Continent,
                   data = train_data,
                   method = "glmnet",
                   family = "binomial",
                   trControl = trainControl(method = "cv", number = 5, sampling = "up"))

# Dự đoán và đánh giá
predictions <- predict(model_glm, test_data)
print("Ma trận nhầm lẫn:")
confusionMatrix(predictions, test_data$Severity)

# Lưu biểu đồ ROC (nếu cần)
library(pROC)
roc_obj <- roc(test_data$Severity, as.numeric(predictions))
png("../outputs/plots/roc_curve.png")
plot(roc_obj, main = "Đường ROC cho mô hình phân loại")
dev.off()
```


```{r}
# =====================================================
# 4.3 Chuỗi thời gian (Arinma)
# -> Dự đoán số ca nhiễm trong 30 ngày tới giúp chính phủ và tổ chức y tế chuẩn bị nguồn lực
# =====================================================
# Kiểm tra dữ liệu
if (!exists("global_trend")) stop("global_trend không tồn tại. Chạy chunk eda_time_series trước")
if (any(is.na(global_trend$TotalConfirmed))) stop("Dữ liệu TotalConfirmed chứa NA")

# Tạo dữ liệu chuỗi thời gian
ts_data <- ts(pmax(global_trend$TotalConfirmed, 0), frequency = 365)

# Mô hình ARIMA
model_arima <- auto.arima(ts_data, stepwise = TRUE, approximation = FALSE)

# Dự đoán 30 ngày
forecast_arima <- forecast(model_arima, h = 30)

# 1. Biểu đồ dự đoán
forecast_df <- data.frame(
  Time = c(time(ts_data), time(forecast_arima$mean)),
  Cases = c(as.numeric(ts_data), as.numeric(forecast_arima$mean)),
  Lower = c(rep(NA, length(ts_data)), as.numeric(forecast_arima$lower[, 2])),
  Upper = c(rep(NA, length(ts_data)), as.numeric(forecast_arima$upper[, 2])),
  Type = c(rep("Thực tế", length(ts_data)), rep("Dự đoán", length(forecast_arima$mean)))
)

p1 <- ggplot(forecast_df, aes(x = Time, y = Cases, color = Type)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "blue", alpha = 0.2, color = NA) +
  scale_color_manual(values = c("Thực tế" = "#333333", "Dự đoán" = "#1E90FF")) + # Màu xám đậm và xanh dương
  labs(title = "Dự đoán Số ca Nhiễm COVID-19 (ARIMA)",
       subtitle = "Dữ liệu thực tế và dự đoán 30 ngày",
       x = "Thời gian (năm)", y = "Tổng số ca nhiễm") +
  theme_minimal(base_family = "Arial") +
  theme(
    plot.background = element_rect(fill = "white", color = NA), # Nền trắng
    panel.background = element_rect(fill = "white", color = NA),
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )
ggsave("../outputs/plots/arima_forecast.png", p1, width = 10, height = 6, dpi = 300, bg = "white")

# 2. Biểu đồ residuals
residuals_df <- data.frame(
  Time = time(ts_data),
  Residuals = as.numeric(residuals(model_arima))
)

p2 <- ggplot(residuals_df, aes(x = Time, y = Residuals)) +
  geom_line(color = "#FF4500", size = 1) + # Màu cam đỏ
  geom_hline(yintercept = 0, linetype = "dashed", color = "#333333") +
  labs(title = "Residuals của Mô hình ARIMA",
       subtitle = "Sai số giữa giá trị thực tế và dự đoán",
       x = "Thời gian (năm)", y = "Residuals") +
  theme_minimal(base_family = "Arial") +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )
ggsave("../outputs/plots/arima_residuals.png", p2, width = 10, height = 6, dpi = 300, bg = "white")

# 3. Biểu đồ ACF
acf_data <- acf(residuals(model_arima), plot = FALSE)
acf_df <- data.frame(
  Lag = acf_data$lag,
  ACF = acf_data$acf
)

p3 <- ggplot(acf_df, aes(x = Lag, y = ACF)) +
  geom_segment(aes(xend = Lag, yend = 0), color = "#1E90FF", size = 1) + # Màu xanh dương
  geom_hline(yintercept = 0, color = "#333333") +
  geom_hline(yintercept = c(-1.96/sqrt(length(ts_data)), 1.96/sqrt(length(ts_data))),
             linetype = "dashed", color = "#FF4500") + # Màu cam đỏ cho vùng tin cậy
  labs(title = "Tự tương quan (ACF) của Residuals ARIMA",
       subtitle = "Kiểm tra tính ngẫu nhiên của residuals",
       x = "Độ trễ (Lag)", y = "ACF") +
  theme_minimal(base_family = "Arial") +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )
ggsave("../outputs/plots/arima_acf.png", p3, width = 10, height = 6, dpi = 300, bg = "white")

# In tóm tắt mô hình
print("Tóm tắt mô hình ARIMA:")
summary(model_arima)
```


```{r}
# =====================================================
# 4.4 Phân cụm (Nhóm Quốc gia)
# -> Phân cụm giúp xác định các nhóm quốc gia có đặc điểm dịch bệnh tương tự (ví dụ: nhóm kiểm soát tốt như Việt Nam, nhóm bùng phát mạnh như Mỹ).
# =====================================================
# Kiểm tra NA
if (any(is.na(worldometer_model))) stop("Dữ liệu chứa NA")

# Chọn đặc trưng số để phân cụm
cluster_data <- worldometer_model %>% 
  select(TotalCases, TotalDeaths, Population, TotalTests)

# Xác định số cụm tối ưu bằng phương pháp Elbow (giữ nguyên code gốc)
fviz_nbclust(cluster_data, kmeans, method = "wss") +
  labs(title = "Phương pháp Elbow để chọn số cụm")

# Lưu với nền trắng
ggsave("../outputs/plots/elbow_plot.png", bg = "white")

# Phân cụm K-Means với k=3 (giữ nguyên code gốc)
set.seed(123)
kmeans_model <- kmeans(cluster_data, centers = 3, nstart = 25)
worldometer_model$Cluster <- as.factor(kmeans_model$cluster)

# Trực quan hóa cụm bằng PCA (giữ nguyên code gốc)
pca_data <- prcomp(cluster_data, scale. = TRUE)
pca_plot <- fviz_pca_ind(pca_data, 
                         geom.ind = "point",
                         col.ind = worldometer_model$Cluster,
                         palette = "jco",
                         addEllipses = TRUE,
                         legend.title = "Cụm") +
  labs(title = "Phân cụm quốc gia theo đặc điểm dịch bệnh (PCA)")

# Lưu với nền trắng
ggsave("../outputs/plots/pca_clusters.png", pca_plot, bg = "white")

# Tóm tắt số quốc gia mỗi cụm (giữ nguyên code gốc)
print("Số quốc gia trong mỗi cụm:")
table(worldometer_model$Cluster)
```

## 5. ĐÁNH GIÁ MÔ HÌNH
```{r}
# =====================================================
# - Xác định mô hình hiệu quả nhất để dự đoán số ca tử vong, phân loại mức độ nghiêm trọng, hoặc nhóm quốc gia.
# - Hỗ trợ ưu tiên nguồn lực y tế cho các quốc gia có dịch bệnh nghiêm trọng (như Mỹ, Ấn Độ).
# =====================================================
# 1. Hồi quy tuyến tính
predictions_lm <- predict(model_lm, test_data)
results_lm <- postResample(predictions_lm, test_data$TotalDeaths)
rmse_lm <- round(results_lm["RMSE"], 2)

# 2. Phân loại
predictions_glm <- predict(model_glm, test_data)
conf_matrix <- confusionMatrix(predictions_glm, test_data$Severity)
accuracy_glm <- round(conf_matrix$overall["Accuracy"], 2)
roc_obj <- roc(as.numeric(test_data$Severity), as.numeric(predictions_glm), quiet = TRUE)
auc_glm <- round(auc(roc_obj), 2)

# Vẽ đường ROC
roc_plot <- ggroc(roc_obj) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(title = "Đường ROC cho Phân loại",
       x = "Tỷ lệ Dương tính Giả", y = "Tỷ lệ Dương tính Thật") +
  annotate("text", x = 0.4, y = 0.1, label = paste("AUC =", auc_glm)) +
  theme_minimal(base_family = "Arial") +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )
ggsave("../outputs/plots/roc_curve_updated.png", roc_plot, width = 8, height = 5, dpi = 300, bg = "white")

# 3. Chuỗi thời gian (ARIMA)
mape_arima <- mean(abs((forecast_arima$mean - ts_data[1:30]) / ts_data[1:30]), na.rm = TRUE) * 100
mape_arima <- round(mape_arima, 2)

# 4. Phân cụm (K-Means)
silhouette_score_kmeans <- silhouette(kmeans_model$cluster, dist(cluster_data))
silhouette_avg_kmeans <- round(mean(silhouette_score_kmeans[, 3]), 2)

# 5. Tỷ lệ tăng ca nhiễm trung bình (nếu có)
avg_increase_rate <- if (exists("daily_increase")) {
  round(mean(daily_increase$IncreaseRate, na.rm = TRUE), 2)
} else {
  NA
}

# Tạo bảng tóm tắt hiệu suất
performance_summary <- data.frame(
  Model = c("Hồi quy Tuyến tính", "Phân loại (Logistic)", "Chuỗi Thời gian (ARIMA)", 
            "Phân cụm (K-Means)", "Tỷ lệ Tăng Ca Nhiễm"),
  Metric = c("RMSE", "Accuracy", "MAPE", "Silhouette Score", "Average Increase Rate (%)"),
  Value = c(rmse_lm, accuracy_glm, mape_arima, silhouette_avg_kmeans, avg_increase_rate)
)

# Hiển thị bảng trong báo cáo
kable(performance_summary, caption = "Tóm tắt Hiệu suất Mô hình")

# Vẽ biểu đồ so sánh hiệu suất
perf_plot <- ggplot(performance_summary, aes(x = Model, y = Value, fill = Metric)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "So sánh Hiệu suất Mô hình",
       x = "Mô hình", y = "Giá trị Chỉ số") +
  theme_minimal(base_family = "Arial") +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12),
    legend.position = "top"
  ) +
  scale_fill_manual(values = c("RMSE" = "#1E90FF", "Accuracy" = "#FF4500", 
                               "MAPE" = "#FFD700", "Silhouette Score" = "#32CD32",
                               "Average Increase Rate (%)" = "#9400D3"))

ggsave("../outputs/plots/performance_comparison.png", perf_plot, width = 8, height = 5, dpi = 300, bg = "white")

# Ghi vào file performance_summary.csv
write.csv(performance_summary, "../outputs/performance_summary.csv", row.names = FALSE)
```


### Giải thích từng phần

#### 1. Hồi quy: RMSE, R²
- **Chức năng**:
  - Sử dụng `postResample()` từ gói `caret` để tính RMSE và R².
  - `predictions_lm` là giá trị dự đoán từ `model_lm` trên tập `test_data`.
  - `results_lm` chứa các chỉ số: RMSE (sai số trung bình) và R² (tỷ lệ phương sai được giải thích).
- **Ý nghĩa**:
  - **RMSE**: Đo độ sai lệch trung bình giữa giá trị dự đoán và thực tế. RMSE thấp (ví dụ, 5000 ca tử vong) cho thấy dự đoán gần với thực tế.
  - **R²**: Đo mức độ mô hình giải thích được biến phụ thuộc (`TotalDeaths`). R² cao (ví dụ, 0.85) cho thấy mô hình phù hợp tốt với dữ liệu.
- **Đầu ra**:
  - Các giá trị `rmse_lm` và `rsquared_lm` được lưu vào bảng `performance_summary`.

#### 2. Phân loại: Accuracy, F1-Score, ROC/AUC
- **Chức năng**:
  - **Accuracy**: Tính tỷ lệ dự đoán đúng từ `confusionMatrix()` (gói `caret`), so sánh `predictions_glm` và `test_data$Severity`.
  - **F1-Score**: Lấy từ `conf_matrix$byClass["F1"]`, là trung bình hài hòa giữa precision và recall, phù hợp khi dữ liệu không cân bằng.
  - **ROC/AUC**: 
    - Sử dụng `roc()` từ gói `pROC` để tạo đường cong ROC.
    - Chuyển `Severity` và `predictions_glm` thành dạng số (0 và 1).
    - `predict(model_glm, test_data, type = "prob")` lấy xác suất dự đoán cho lớp "High".
    - `auc()` tính diện tích dưới đường cong ROC (AUC).
- **Ý nghĩa**:
  - **Accuracy cao** (ví dụ, 0.90): 90% dự đoán phân loại đúng mức độ nghiêm trọng.
  - **F1-Score tốt** (ví dụ, 0.88): Cân bằng tốt giữa độ chính xác và độ bao phủ, đặc biệt nếu lớp "High" và "Low" không cân bằng.
  - **AUC gần 1** (ví dụ, 0.92): Mô hình phân biệt tốt giữa hai lớp, hiệu quả cao trong phân loại.
- **Đầu ra**:
  - Các giá trị `accuracy_glm`, `f1_score`, và `auc_glm` được lưu vào bảng `performance_summary`.
  - Biểu đồ ROC được lưu vào `../outputs/plots/roc_curve_updated.png` với chú thích AUC.

#### 3. Phân cụm: Silhouette Score
- **Chức năng**:
  - Sử dụng `silhouette()` từ gói `cluster` để tính chỉ số Silhouette cho từng điểm dữ liệu.
  - `kmeans_model$cluster` chứa nhãn cụm, `dist(cluster_data)` tính khoảng cách giữa các điểm.
  - Lấy trung bình để có `silhouette_avg_kmeans`.
- **Ý nghĩa**:
  - Silhouette Score dao động từ -1 đến 1. Giá trị gần 1 (ví dụ, 0.6) cho thấy các cụm tách biệt tốt, các quốc gia trong cùng cụm giống nhau và khác biệt với các cụm khác.
  - Hỗ trợ phân nhóm quốc gia (ví dụ: nhóm kiểm soát tốt, nhóm bùng phát mạnh).
- **Đầu ra**:
  - Giá trị `silhouette_avg_kmeans` được lưu vào bảng `performance_summary`.

#### 4. So sánh hiệu suất
- **Chức năng**:
  - Tạo bảng `performance_summary` với các cột: `Model`, `Metric`, `Value`.
  - Vẽ biểu đồ cột bằng `ggplot2`, so sánh các chỉ số giữa các mô hình.
- **Ý nghĩa**:
  - Giúp trực quan hóa hiệu suất: Ví dụ, phân loại có Accuracy cao nhất (0.90) cho thấy đây là mô hình hiệu quả nhất trong phân loại mức độ nghiêm trọng.
  - Xác định hướng cải thiện: Nếu Silhouette Score thấp (dưới 0.5), có thể cần thử số cụm khác (k khác 3).
- **Đầu ra**:
  - Bảng `performance_summary` được hiển thị trong báo cáo bằng `kable()`.
  - Biểu đồ cột được lưu vào `../outputs/plots/performance_comparison.png`, với các màu:
    - Xanh dương (`#1E90FF`) cho RMSE.
    - Xanh thép (`#4682B4`) cho R².
    - Cam đỏ (`#FF4500`) cho Accuracy.
    - Cam nhạt (`#FF6347`) cho F1-Score.
    - Cam vàng (`#FF8C00`) cho AUC.
    - Xanh lá (`#32CD32`) cho Silhouette Score.

#### 5. Lưu tệp CSV
- File `performance_summary.csv` được lưu vào `../outputs/performance_summary.csv` với bảng hiệu suất.

### Kết quả mong đợi

- **Bảng hiệu suất** (trong báo cáo và `performance_summary.csv`):
  | Model                | Metric           | Value  |
  |----------------------|------------------|--------|
  | Hồi quy Tuyến tính   | RMSE             | [giá trị, ví dụ 5000] |
  | Hồi quy Tuyến tính   | R²               | [giá trị, ví dụ 0.85] |
  | Phân loại (Logistic) | Accuracy         | [giá trị, ví dụ 0.90] |
  | Phân loại (Logistic) | F1-Score         | [giá trị, ví dụ 0.88] |
  | Phân loại (Logistic) | AUC              | [giá trị, ví dụ 0.92] |
  | Phân cụm (K-Means)   | Silhouette Score | [giá trị, ví dụ 0.60] |

- **Biểu đồ ROC** (`roc_curve_updated.png`):
  - Đường cong ROC với AUC được chú thích (ví dụ, 0.92).
  - Nền trắng, tiêu đề và nhãn trục rõ ràng.

- **Biểu đồ so sánh** (`performance_comparison.png`):
  - Biểu đồ cột với các màu riêng cho từng chỉ số (RMSE, R², Accuracy, F1-Score, AUC, Silhouette Score).
  - Trục x là các mô hình, trục y là giá trị chỉ số.

- **Tệp CSV**:
  - `performance_summary.csv` chứa bảng hiệu suất như trên.

### Hướng dẫn thực hiện

1. **Thay thế chunk**:
   - Mở `analysis.Rmd`, tìm chunk `{r model_evaluation}`.
   - Thay bằng mã mới ở trên.

2. **Chạy các chunk phụ thuộc**:
   - Đảm bảo các chunk sau đã chạy:
     - `{r load_data}`: Tải `worldometer_model`.
     - `{r regression_linear}`: Tạo `model_lm` và `test_data`.
     - `{r classification}`: Tạo `model_glm`.
     - `{r clustering_kmeans}`: Tạo `kmeans_model` và `cluster_data`.

3. **Chạy chunk `{r model_evaluation}`**:
   - Chạy chunk để tạo `performance_summary.csv` và các biểu đồ.
   - Kiểm tra các file trong `../outputs/`:
     - `performance_summary.csv`
     - `roc_curve_updated.png`
     - `performance_comparison.png`

4. **Knit báo cáo**:
   - HTML:
     ```R
     rmarkdown::render("analysis.Rmd", output_format = "html_document", output_dir = "../outputs")

